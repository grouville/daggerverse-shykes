// A generated module for Termcast functions
//
// This module has been generated via dagger init and serves as a reference to
// basic module structure as you get started with Dagger.
//
// Two functions have been pre-created. You can modify, delete, or add to them,
// as needed. They demonstrate usage of arguments and return types using simple
// echo and grep commands. The functions can be called from the dagger CLI or
// from one of the SDKs.
//
// The first line in this comment block is a short description line and the
// rest is a long description with more detail on the module's purpose or usage,
// if appropriate. All modules should have a short description.

package main

import (
	"context"
	"strings"
	"math/rand"
	"time"
	"encoding/json"
)

func New(
	// Terminal width
	// +default=80
	width int,
	// Terminal height
	// +default=24
	height int,
) *Termcast {
	return &Termcast{
		Height: height,
		Width: width,
	}
}

type Termcast struct{
	Title string
	Height int
	Width int
	Events []*Event
	// Time elapsed since beginning of the session, in milliseconds
	Clock int
}

type Event struct {
	Time int // milliseconds
	Code string
	Data string
}

func (e *Event) Encode() (string, error) {
	out, err := json.Marshal([3]interface{}{float64(e.Time) / 1000, e.Code, e.Data})
	return string(out), err
}

func (m *Termcast) Print(data string) *Termcast {
	m.Events = append(m.Events, &Event{
		Time: m.Clock,
		Code: "o",
		Data: strings.Replace(data, "\n", "\r\n", -1),
	})
	return m
}

func (m *Termcast) Append(other *Termcast) *Termcast {
	for _, e := range other.Events {
		 newEvent := &Event{
			Time: m.Clock + e.Time,
			Code: e.Code,
			Data: e.Data,
		}
		m.Events = append(m.Events, newEvent)
		if newEvent.Time > m.Clock {
			m.Clock = newEvent.Time
		}
	}
	return m
}


func (m *Termcast) WaitRandom(min, max int) *Termcast {
	rand.Seed(time.Now().UnixNano())
	return m.Wait(min + rand.Intn(max - min))
}

func (m *Termcast) Wait(
	// wait time, in milliseconds
	ms int,
) *Termcast {
	m.Clock += ms
	return m
}

func (m *Termcast) Keystrokes(
	// Data to input as keystrokes
	data string,
) *Termcast {
	for _, c := range data {
		m = m.Keystroke(string(c))
	}
	return m
}

func (m *Termcast) Keystroke(
	// Data to input as keystrokes
	data string,
) *Termcast {
	return m.WaitRandom(5, 200).Print(data)
}

// Simulate pressing the enter key
func (m *Termcast) Enter() *Termcast {
	return m.Keystroke("\r\n")
}

// Simulate pressing the backspace key
func (m *Termcast) Backspace(
	// Number of backspaces
	// +default=1
	repeat int,
) *Termcast {
	for i := 0; i < repeat; i += 1 {
		m = m.Keystroke("\b \b")
	}
	return m
}

func (m *Termcast) Encode() (string, error) {
	var out strings.Builder
	if err := json.NewEncoder(&out).Encode(map[string]interface{}{
		"version": 2,
		"width": m.Width,
		"height": m.Height,
	}); err != nil {
		return out.String(), err
	}
	for _, e := range m.Events {
		line, err := e.Encode()
		if err != nil {
			return out.String(), err
		}
		out.Write([]byte(line + "\n"))
	}
	return out.String(), nil
}

func (m *Termcast) Castfile() (*File, error) {
	contents, err := m.Encode()
	if err != nil {
		return nil, err
	}
	castfile := dag.
		Directory().
		WithNewFile("castfile", contents).
		File("castfile")
	return castfile, nil
}


func (m *Termcast) Play() (*Terminal, error) {
	castfile, err := m.Castfile()
	if err != nil {
		return nil, err
	}
	term := dag.
		Container().
		From("ghcr.io/asciinema/asciinema").
		WithoutEntrypoint().
		WithFile("term.cast", castfile).
		Terminal(ContainerTerminalOpts{
			Cmd: []string{"asciinema", "play", "term.cast"},
		})
	return term, nil
}

func (m *Termcast) Demo() *Termcast {
	var message = `hello daggernauts! this recording is entirely generated by a dagger function :)`
	return m.
		Print("$ ").
		Keystrokes("echo " + message).
		Enter().
		Print(message).Enter().
		Print("$ ").
		Keystrokes("ls -l").Enter().
		WaitRandom(1000, 2000).
		Print(`
total 32
-rw-------@  1 shykes  staff  10280 Feb 15 15:49 LICENSE
drwxr-xr-x@ 11 shykes  staff    352 Feb 21 15:30 containers
drwxr-xr-x   4 shykes  staff    128 Mar  1 17:48 core
drwxr-xr-x@ 16 shykes  staff    512 Mar  6 12:46 dagger
-rw-r--r--   1 shykes  staff    124 Mar  8 13:46 dagger.json
drwxr-xr-x@ 17 shykes  staff    544 Mar  3 21:54 daggy
drwxr-xr-x   9 shykes  staff    288 Feb 21 15:30 datetime
drwxr-xr-x  13 shykes  staff    416 Mar  4 11:28 docker
drwxr-xr-x  13 shykes  staff    416 Mar  2 01:02 docker-compose
drwxr-xr-x@ 11 shykes  staff    352 Mar  7 13:16 dsh
drwxr-xr-x@  3 shykes  staff     96 Feb 21 14:36 go
drwxr-xr-x@  9 shykes  staff    288 Feb 21 15:30 gptscript
drwxr-xr-x  12 shykes  staff    384 Feb 21 15:30 graphiql
drwxr-xr-x@ 11 shykes  staff    352 Feb 21 15:30 hello
drwxr-xr-x   9 shykes  staff    288 Feb 21 15:30 imagemagick
drwxr-xr-x   7 shykes  staff    224 Feb 21 15:30 make
drwxr-xr-x   8 shykes  staff    256 Feb 21 15:30 myip
drwxr-xr-x   9 shykes  staff    288 Jan 25 00:10 ollama
drwxr-xr-x   3 shykes  staff     96 Mar  6 12:38 scratch
drwxr-xr-x@ 12 shykes  staff    384 Feb 21 15:30 slim
drwxr-xr-x@ 11 shykes  staff    352 Mar  6 12:22 supercore
drwxr-xr-x  14 shykes  staff    448 Feb 21 15:30 supergit
drwxr-xr-x@ 11 shykes  staff    352 Feb 21 15:30 tailscale
drwxr-xr-x  14 shykes  staff    448 Mar  9 02:26 termcast
drwxr-xr-x  12 shykes  staff    384 Feb 21 15:30 tmate
drwxr-xr-x   8 shykes  staff    256 Feb 21 15:30 ttlsh
drwxr-xr-x  10 shykes  staff    320 Feb 26 13:09 utils
drwxr-xr-x@ 12 shykes  staff    384 Feb 21 15:30 wolfi
`).
		Wait(1000)
}

func (m *Termcast) Gif() (*File, error) {
	agg := dag.
		Git("https://github.com/asciinema/agg").
		Tag("v1.4.3").
		Tree().
		DockerBuild().
		WithoutEntrypoint()
	castfile, err := m.Castfile()
	if err != nil {
		return nil, err
	}
	gif := agg.
		WithMountedFile("term.cast", castfile).
		WithExec([]string{"agg", "term.cast", "cast.gif"}).
		File("cast.gif")
	return gif, nil
}

func (m *Termcast) AI(ctx context.Context, token *Secret, steps []string) (string, error) {
	prompt, err := m.RawPrompt(ctx, steps)
	if err != nil {
		return "", err
	}
	return dag.Daggy().Do(ctx, prompt, DaggyDoOpts{
		Token: token,
	})
}

func (m *Termcast) RawPrompt(ctx context.Context, steps []string) (string, error) {
	systemPrompt, err := dag.CurrentModule().Source().File("prompt.txt").Contents(ctx)
	if err != nil {
		return "", err
	}
	parts := append([]string{systemPrompt}, steps...)
	return strings.Join(parts, "\n- "), nil
}


func (m *Termcast) Example(ctx context.Context, token *Secret) (string, error) {
	return m.AI(ctx, token, []string{
		`The terminal shows a shell prompt. Pause one second.`,
		`Type the command "ls -l". Break down each character, with a slight delay to reflect human typing speed`,
		`The command prints a realistic listing of a directory.`,
		`Pause 3 seconds.`,
	})
}
